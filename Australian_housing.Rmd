---
title: "Australian housing"
author: "Arindam Baruah"
date: "2023-06-13"
output:
  bookdown::html_document2:
   
    css: CSSBackground.css
    toc: true
    toc_float: true
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

```{r}
library(tidyverse)
library(naniar)
library(bookdown)
library(stringr)
library(stringi)
library(lubridate)
library(DT)
library(forcats)
library(ggthemes)
```

# Checking the data quality

One of the first steps we need to perform is to analyse the quality of the dataset.

First, we read in the dataset

```{r read-data}

df_oz <- read_csv("data/RealEstateAU_1000_Samples.csv")
head(df_oz)
```

## Check for null values

For this purpose, we check the presence of null values in each of the variables using a heatmap.

```{r nullheatmap, fig.cap="Heat map for null values",fig.align='center'}

vis_miss(df_oz)

```

As we can observe from figure \@ref(fig:nullheatmap),

-   There are no values of latitude and longitude in the dataset. Hence, these variables can be dropped.
-   There are fairly high number of missing values for the variables building size, land size, preferred size and open date. These will not be dropped but care must be taken while using these variables.
-   Remaining variables have very low number of missing values. Hence, they can be used for our analysis without much concern.

# Data cleaning

The next step is to clean the dataset and make it ready for analysis.

## Feature selection

In this step, we will be retaining the important variables which could yield important results in our analysis. Variables falling under the following categories will be removed from the dataset:

-   Variables which do not contribute any meaningful insights. (index, TID, breadcrumb,phone,product_depth)
-   Variables with high number of null values. (latitude, longitude)
-   Redundant columns which contain the same data. (Price and location_name variables contain the same data, which is the price of the property. Hence, location_name will be removed.)

```{r feature-selection}

remove_variables <- c("index","TID","breadcrumb","phone","product_depth","latitude","longitude","location_name","address","RunDate","category_name","location_type")
df_oz_clean <- df_oz %>% select(-remove_variables)
```

## Building land and preferrezed size

The various variables related to property and land sizes will be cleaned to cast them into numerical variable types.

```{r size-num}

df_oz_clean$building_size <-as.numeric((gsub("([0-9]+).*$", "\\1", df_oz_clean$building_size)))
df_oz_clean$land_size <-as.numeric((gsub("([0-9]+).*$", "\\1", df_oz_clean$land_size)))
df_oz_clean$preferred_size <-as.numeric((gsub("([0-9]+).*$", "\\1", df_oz_clean$preferred_size)))

```

## Price

The price variable will be converted to a numerical variable from the current character variable.

```{r price}

df_oz_clean$price <-as.numeric(gsub("\\D", "", df_oz_clean$price))


```

## Address

As the exact unit address does not provide us with any additional data, hence we shall simply retain the street address.

```{r address}
df_oz_clean$address_1 <-as.character(gsub("[^a-zA-Z]", " ", df_oz_clean$address_1))
stop_words <- c("Lot","Unit","UNIT")
df_oz_clean$address_1 <- str_remove(df_oz_clean$address_1, "Lot")
df_oz_clean$address_1 <- str_remove(df_oz_clean$address_1, "UNIT")
df_oz_clean$address_1 <- str_remove(df_oz_clean$address_1, "Unit")
df_oz_clean$address_1 <- str_squish(df_oz_clean$address_1)

df_oz_clean <- df_oz_clean %>% rename( "street_address" =  "address_1")

```

## Open date

We will try to clean the variable by changing the variable to date type. For this purpose, a reference date of 29th November, 2022 (Date of dataset upload on Kaggle) has been chosen.

```{r open-date}

df_oz_clean$open_date <- if_else(df_oz_clean$open_date == "Added yesterday","1",df_oz_clean$open_date)
df_oz_clean$open_date <- if_else(str_detect(df_oz_clean$open_date,"hour"),"0",df_oz_clean$open_date)
df_oz_clean$open_date <-as.numeric(gsub("\\D", "", df_oz_clean$open_date))
df_oz_clean$open_date <- (ymd(20221029) - days(df_oz_clean$open_date))

```


## Finalised clean data

Here is a glimpse of the dataset after the completion of all the data cleaning operations.


```{r clean-data}

df_oz_clean %>% DT::datatable()

```
# Exploratory Data analysis

In the next step, we will try to visualise the data through relevant plots and attempt to understand how each of these variables maybe correlated to the price of the property.

## Property type

Let us visualise the number of available properties by its type.

```{r property-type, fig.cap="Distribution of property types up for sale",fig.align='center'}

df_oz_type_group <- df_oz_clean %>% count(property_type)

pl1 <- ggplot(data = df_oz_type_group,aes(x = reorder(property_type,-n),y = n,fill = property_type)) +
                                   geom_col(color = 'black') + geom_label(aes(label = n),nudge_y =20) + labs(x = "Property type",y =" Number of available properties") + ggtitle("Available properties for sale") +        theme_classic() +
                                   theme(axis.text.x = element_text(angle =10, size = 6), plot.title = element_text(hjust = 0.5),legend.position = "None") +
                                   scale_fill_brewer(palette = "Pastel1") 
pl1


```
Figure \@ref(fig:property-type) illustrates that __houses are the most abundantly available in the market with 441 listed properties followed by units at 230 listings and then apartments with 212 listings. The remaining property types are observed to constitute a small portion of the available listings__.

Let us now observe how do the prices of these properties differ for each of the property types.

```{r fig-box,fig.align='center',fig.cap="Presence of outlier values in property type"}
pl2 <- ggplot(data = df_oz_clean, aes(x = property_type,y = price)) + geom_boxplot()
pl2

```

As we can observe from figure \@ref(fig:fig-box), there is a presence of an outlier value which has completely skewed the distribution of the variables. We will replace this outlier value with a null and create a new plot for to analyse the prices for each property types.

```{r outlier-removal}

outlier <-  1.5* IQR(df_oz_clean$price, na.rm =TRUE) + quantile(df_oz_clean$price,0.75,na.rm = TRUE)
df_oz_clean <- df_oz_clean %>% mutate(new_price = if_else(price >= outlier, NA, price ))
```

After removing the outliers, let us try to visualise the plot for prices against property types.

```{r box-plot, fig.cap="Median prices for each property type",fig.align='center'}

level_order <- c("Acreage","Other","House","Townhouse","Villa","Apartment","Unit","Studio","Duplex/Semi-detached")
pl3 <-
  ggplot(
    data = df_oz_clean,
    aes(x = factor(property_type,level = level_order), y = new_price, fill = property_type)) + geom_boxplot() + labs(x = "Property type", 
                                                                    y ="Price of property ($0") + ggtitle("Price dsitribution of properties") +        theme_classic() +
      theme(
        axis.text.x = element_text(angle = 10, size = 6),
        plot.title = element_text(hjust = 0.5),
        legend.position = "None"
      ) +
      scale_fill_brewer(palette = "Set2") 
pl3


```
Figure \@ref(fig:box-plot) illustrates the distributions of the prices for each of the property types. We can observe that Acreage properties have the highest median price while studio property types cost the least. There is a high variability observed in the reported prices for Townhouses as can be observed through the large interquartile range.


# Bedroom availability

Let us look into the prices of the properties based on the number of bedrooms available in each property.

```{r bed-count,fig.cap="Number of properties for each bedroom count",fig.align='center'}

df_group_bedrooms <- df_oz_clean %>% count(bedroom_count)
pl4 <- ggplot(data = df_group_bedrooms, aes(x = bedroom_count,y = n)) + geom_col(color = 'black',aes(fill = factor(bedroom_count))) + scale_x_continuous(breaks = c(0:max(df_oz_clean$bedroom_count,na.rm = TRUE))) + geom_label(aes(label = n),nudge_y =20) + labs(x = "Number of bedrooms",y =" Number of available properties") + ggtitle("Available properties for sale") +        theme_classic() +
                                   theme(axis.text.x = element_text(size = 9), plot.title = element_text(hjust = 0.5),legend.position = "None") +
                                   scale_fill_brewer(palette = "Pastel1") 
pl4
```
As we can observe from figure \@ref(fig:bed-count), __properties with 3 bedrooms are the most available for sale followed by properties with 2 bedrooms and then subsequently, properties with 4 bedrooms__.

Let us now check how do the prices differ for each bedroom count.

```{r price-bedroom, fig.cap="Prices of properties for each bedroom count",fig.align='center'}

levels <- c(0,1,2,3,4,5,6)

pl5 <- ggplot(data = df_oz_clean , aes(x = factor(bedroom_count,levels = levels),y = new_price)) + geom_boxplot(aes(fill = factor(bedroom_count))) + labs(x ="Bedroom count",y = "Price of property ($)") + theme_economist()+ theme(legend.position = 'none') + ggtitle("Prices of properties for each bedroom count") 
pl5
```
As we can observe through figure \@ref(fig:price-bedroom), there is a steady rise in the median prices of the properties with higher counts of bedrooms. Hence, __more number of bedrooms can be associated with a higher price tag of the property.__
